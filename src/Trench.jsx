/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 deathstar-trench-turret.glb --keepnames --transform
*/

import React, { useEffect, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import { useFrame } from "@react-three/fiber";
import { Projectile } from "./Projectile";
import { RigidBody } from "@react-three/rapier";
import gsap from "gsap";

function handleMouse(pos, ref, ringOne, ringTwo, shotsFired, setProjectiles, light) {
  const projectilePosition = pos.clone();
  const projectileRotation = ref.rotation.clone();
  projectilePosition.y -= 18;
  // projectileRotation.x += Math.PI / 2;



  if (shotsFired === 1) {
    projectilePosition.x = projectilePosition.x + 0.2;
    animateShoot(ringOne, light);
  } else if (shotsFired === 2) {
    projectilePosition.x = projectilePosition.x - 0.2;
    animateShoot(ringTwo, light);
  }
  const quaternion = ref.quaternion.clone();
  //invert quternion

  // quaternion.conjugate();

  const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(
    quaternion
  );
  setProjectiles((prev) => [
    ...prev,
    {
      position: projectilePosition,
      rotation: projectileRotation,
      forwardVector: forwardVector,
      enemy: true,
    },
  ]);
}

function animateShoot(ref, light) {
  gsap.set(ref.scale, {
    x: 0,
    y: 0,
    z: 0,
  });
  gsap.set(light, {
    intensity: 0,
  });
  gsap.set(ref.material, {
    opacity: 1,
  });
  gsap.to(ref.scale, {
    x: 0.1,
    y: 0.1,
    z: 0.1,
    duration: 0.2,
    ease: "expo.out",
  });
  gsap.to(light, {
    intensity: 0.5,
    duration: 0.2,
    ease: "expo.out",
  });
  gsap.to(ref.material, {
    opacity: 0,
    duration: 0.2,
    ease: "expo.out",
  });
  gsap.to(light, {
    intensity: 0,
    duration: 0.3,
    delay: 0.2,
    ease: "expo.out",
  });
}

export function TrenchTurret(props) {
  const group = useRef();
  const { nodes, materials } = useGLTF("/trench-transformed.glb");

  useEffect(() => {
    materials.Hullplates2.metalness = 0.3;
    materials.Hullplates2.roughness = 0.5;
    materials.Hullplates2.color = new THREE.Color(0x8e8e8e);
  }, []);

  useFrame(({ camera }) => {
    if (camera.position.z - group.current.position.z > 132.5) {
      group.current.position.z = camera.position.z;
    }
  });
  return (
    <>
      <group ref={group} {...props} dispose={null}>
        {Array(10)
          .fill()
          .map((_, i) => (
            <group
              name="DeathStarTrench"
              position={[-0.2, 0, i * 26.5]}
              rotation={[-Math.PI / 2, 0, Math.PI / 2]}
              scale={1}
              key={i}
            >
              <mesh
                name="DeathStarTrench001"
                geometry={nodes.DeathStarTrench001.geometry}
                material={materials.Hullplates2}
                position={[0, 0, 0]}
                rotation={[0, 0, 0]}
              />
            </group>
          ))}
      </group>

























































































































































      
      <Turret position={[0, -18.3, 100]} materials={materials} nodes={nodes} />
    </>
  );
}

function Turret({ position, materials, nodes }) {
  const ref = useRef();
  const head = useRef();
  const cannons = useRef();
  const shotsFired = useRef(0);
  const lastShotTime = useRef(0);
  const mousePressed = useRef(true);
  const ringOne = useRef();
  const ringTwo = useRef();
  const lightOne = useRef();
  const lightTwo = useRef();
  const [projectiles, setProjectiles] = useState([]);
  const mesh = useRef();
  const offsetY = position[1] * -1 - 4; 


  useFrame(({ clock, camera }) => {
    const currentTime = clock.getElapsedTime();
    const distance = ref.current.position.distanceTo(camera.position);
    if(distance < 50) {
      mousePressed.current = true;
    const wingsPosition = camera.position.clone();
    mesh.current = cannons.current.clone()

    wingsPosition.z += 5;
    head.current.lookAt(wingsPosition);
    head.current.rotation.x = 0;
    head.current.rotation.z = 0;
    cannons.current.lookAt(wingsPosition);
    // cannons.current.rotation.z = 0;
    
    const projectilePosition = ref.current.position.clone();
    projectilePosition.y = cannons.current.position.y;
    mesh.current.rotation.x *= -1;
    cannons.current.rotation.z = 0;
    


    if (shotsFired.current === 2) {
      if (currentTime - lastShotTime.current > 2) {
        shotsFired.current = 0;
      }
    }
    if (
      mousePressed.current &&
      currentTime - lastShotTime.current > 0.2
    ) {
      handleMouse(
        projectilePosition,
        mesh.current,
        ringOne.current,
        ringTwo.current,
        1,
        setProjectiles,
        lightOne.current
      );
      handleMouse(
        projectilePosition,
        mesh.current,
        ringOne.current,
        ringTwo.current,
        2,
        setProjectiles,
        lightTwo.current
      );
      lastShotTime.current = currentTime;
      shotsFired.current += 1;
    }
    mesh.current.visible = false;
  } else {
    mousePressed.current = false;
  }
});

  return (
    <>
    <group ref={ref} rotation-y={Math.PI} position={position}>
    <RigidBody type="fixed" position-y={offsetY}>
        <mesh visible={false}>
          <boxGeometry args={[1.5, 4, 0.5]} />
        </mesh>
      </RigidBody>
      <mesh
        name="Body"
        geometry={nodes.Body.geometry}
        material={materials.Hullplates2}
        position={[0, 13.1, 0]}
      />
      <group>
        <mesh
          ref={head}
          name="HEAD"
          geometry={nodes.HEAD.geometry}
          material={materials.Hullplates2}
          position={[0, 15.8, 0]}
        />
        <mesh
          ref={cannons}
          name="cannons"
          geometry={nodes.cannons.geometry}
          material={materials.Hullplates2}
          position={[0, 15.7, 0.21]}
          rotation={[0.28, 0, 0]}
          scale={1}
        />
        <mesh ref={mesh} visible={false}>

        </mesh>
         <mesh
            ref={ringOne}
            position={[0.2, 15.7, -1]}
            scale={0}
            rotation={[0, 0, 0]}
          >
            <ringGeometry args={[1, 0.6, 16]} />
            <meshStandardMaterial
              emissive="#00FF00"
              emissiveIntensity={1500}
              toneMapped={false}
              transparent
              side={THREE.DoubleSide}
            />
            <pointLight
              ref={lightOne}
              intensity={0}
              color="#00FF00"
              distance={10}
            />
          </mesh>
          <mesh
            ref={ringTwo}
            position={[-0.2, 15.7, -1]}
            scale={0}
            rotation={[0, 0, 0]}
          >
            <ringGeometry args={[1, 0.6, 16]} />
            <meshStandardMaterial
              emissive="#00FF00"
              emissiveIntensity={1500}
              toneMapped={false}
              transparent
              side={THREE.DoubleSide}
            />
            <pointLight
              ref={lightTwo}
              intensity={0}
              color="#00FF00"
              distance={10}
            />
          </mesh>
      </group>
    </group>
    {projectiles.map((projectile, index) => (
        <Projectile
          position={projectile.position}
          rotation={projectile.rotation}
          forwardVector={projectile.forwardVector}
          enemy={true}
          key={index}
        />
      ))}
    </>
    
  );
}
useGLTF.preload("/deathstar-trench-turret-transformed.glb");
